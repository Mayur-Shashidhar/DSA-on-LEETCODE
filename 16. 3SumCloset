QUESTION:
Given an integer array nums of length n and an integer target, find three integers in nums such that the sum is closest to target.
Return the sum of the three integers.
You may assume that each input would have exactly one solution.



APPROACH:
Sorting + Two Pointers (O(n²))
We can solve this problem similar to 3Sum but instead of finding sum == target, we track the closest difference.
Steps:
1.Sort the array — makes two-pointer scanning easier.
2.Loop i from 0 to n-3:
    1.Use two pointers:
        1.left = i+1 and right = n-1.
    2.Compute sum = nums[i] + nums[left] + nums[right].
    3.If |sum - target| is smaller than the best seen, update closest.
    4.If sum < target → move left++ (we want a bigger sum).
    5.If sum > target → move right-- (we want a smaller sum).
    6.If sum == target → exact match found, return it immediately.
3.Return the closest sum after the loop.


CODE:
#include <stdio.h>
#include <stdlib.h>
#include <limits.h>


int cmp(const void *a, const void *b) {
    return (*(int *)a - *(int *)b);
}

int threeSumClosest(int* nums, int numsSize, int target) {
    qsort(nums, numsSize, sizeof(int), cmp); 

    int closest = nums[0] + nums[1] + nums[2]; 

    for (int i = 0; i < numsSize - 2; i++) {
        int left = i + 1;
        int right = numsSize - 1;

        while (left < right) {
            int sum = nums[i] + nums[left] + nums[right];

            
            if (abs(sum - target) < abs(closest - target)) {
                closest = sum;
            }

            if (sum < target) {
                left++;  
            } else if (sum > target) {
                right--; 
            } else {
                return sum; 
            }
        }
    }
    return closest;
}
