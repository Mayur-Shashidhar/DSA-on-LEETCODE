QUESTION:
Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.
An input string is valid if:
Open brackets must be closed by the same type of brackets.
Open brackets must be closed in the correct order.
Every close bracket has a corresponding open bracket of the same type.


APPROACH:
Stack
The stack data structure is perfect for this:
1.Traverse the string from left to right.
2.If the character is an opening bracket, push it onto the stack.
3.If it’s a closing bracket:
    1.If the stack is empty → invalid (no matching open).
    2.Pop from the stack and check if it matches the type of closing bracket.
4.At the end, if the stack is empty, the string is valid, else invalid.



CODE:
#include <stdbool.h>
#include <string.h>

bool isValid(char *s) {
    // Create a stack to hold opening brackets
    // Size = length of s (max stack depth = num of chars in s)
    char stack[strlen(s)];
    int top = -1; // Stack pointer (-1 means empty stack)

    // Iterate over each character in the string
    for (int i = 0; s[i] != '\0'; i++) {
        char c = s[i];
        
        // If it's an opening bracket, push to stack
        if (c == '(' || c == '{' || c == '[') {
            stack[++top] = c;
        } 
        else { // It’s a closing bracket
            if (top == -1) 
                return false; // No matching opening → invalid
            
            // Pop from stack
            char topChar = stack[top--];

            // Check if the popped opening matches the closing bracket
            if ((c == ')' && topChar != '(') ||
                (c == '}' && topChar != '{') ||
                (c == ']' && topChar != '[')) {
                return false; // Type mismatch → invalid
            }
        }
    }

    // At the end, stack must be empty for a valid string
    return top == -1;
}
