QUESTION:
Given two integers dividend and divisor, divide two integers without using multiplication, division, and mod operator.
The integer division should truncate toward zero, which means losing its fractional part. For example, 8.345 would be truncated to 8, and -2.7335 would be truncated to -2.
Return the quotient after dividing dividend by divisor.
Note: Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: [−231, 231 − 1]. For this problem, if the quotient is strictly greater than 231 - 1, then return 231 - 1, and if the quotient is strictly less than -231, then return -231.



APPROACH:
Bit Manipulation + Subtraction
Instead of dividing directly, we repeatedly subtract multiples of divisor, increasing the multiple exponentially using left shifts.
Steps:
1.Handle Edge Case Overflow:
    If dividend == INT_MIN and divisor == -1, the result would be INT_MAX + 1 (overflow), so return INT_MAX.
2.Determine sign:
    negative = (dividend < 0) ^ (divisor < 0)
3.Work with absolute values:
    Use long long temporarily to handle INT_MIN without overflow when taking abs
4.Efficient subtraction using bit shifts:
    For each iteration:
      Find the largest shifted divisor ≤ dividend
      Subtract it from dividend
      Add corresponding power-of-two multiple to result
5.Apply sign and return



CODE:
#include <limits.h> // For INT_MAX, INT_MIN
#include <stdlib.h> // For llabs

int divide(int dividend, int divisor) {
    // Handle overflow edge cases:
    // INT_MIN / -1 would overflow 32-bit int → clamp to INT_MAX
    if (dividend == INT_MIN && divisor == -1) return INT_MAX;
    // INT_MIN / 1 is just INT_MIN (no overflow, but handle separately for clarity)
    if (dividend == INT_MIN && divisor == 1) return INT_MIN;
    
    // Determine if the result should be negative (true if signs differ)
    int negative = (dividend < 0) ^ (divisor < 0);

    // Convert both numbers to positive long long to avoid overflow during abs
    long long a = llabs((long long)dividend);
    long long b = llabs((long long)divisor);
    
    long long result = 0;

    // Repeat until dividend >= divisor
    while (a >= b) {
        long long temp = b;      // Current divisor multiple
        long long multiple = 1;  // Corresponding multiple of divisor

        // Keep doubling temp until it is the largest possible chunk <= a
        // This maximizes subtraction step size and speeds up the process
        while (a >= (temp << 1)) {
            temp <<= 1;        // Double the divisor
            multiple <<= 1;    // Double the multiple
        }

        a -= temp;           // Subtract the chunked divisor from dividend
        result += multiple;  // Add the corresponding multiple to result
    }

    // Apply sign
    if (negative) result = -result;

    // Clamp to 32-bit signed integer range
    if (result > INT_MAX) return INT_MAX;
    if (result < INT_MIN) return INT_MIN;

    return (int)result;
}
