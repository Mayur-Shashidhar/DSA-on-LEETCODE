QUESTION:
We can scramble a string s to get a string t using the following algorithm:
1.If the length of the string is 1, stop.
2.If the length of the string is > 1, do the following:
    Split the string into two non-empty substrings at a random index, i.e., if the string is s, divide it to x and y where s = x + y.
    Randomly decide to swap the two substrings or to keep them in the same order. i.e., after this step, s may become s = x + y or s = y + x.
    Apply step 1 recursively on each of the two substrings x and y.
Given two strings s1 and s2 of the same length, return true if s2 is a scrambled string of s1, otherwise, return false.



APPROACH:
Topâ€‘Down DP + Memoization



CODE:
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>


int dp[31][31][31];

bool isSameChars(const char *s1, const char *s2, int len) {
    int count[26] = {0};
    for (int i = 0; i < len; i++) {
        count[s1[i] - 'a']++;
        count[s2[i] - 'a']--;
    }
    for (int i = 0; i < 26; i++)
        if (count[i] != 0) return false;
    return true;
}

bool helper(const char *s1, const char *s2, int i1, int i2, int len) {
    if (dp[i1][i2][len] != -1)
        return dp[i1][i2][len];

    
    if (strncmp(s1 + i1, s2 + i2, len) == 0) {
        return dp[i1][i2][len] = 1;
    }

    if (!isSameChars(s1 + i1, s2 + i2, len)) {
        return dp[i1][i2][len] = 0;
    }

    for (int k = 1; k < len; k++) {
       
        if (helper(s1, s2, i1, i2, k) && helper(s1, s2, i1 + k, i2 + k, len - k))
            return dp[i1][i2][len] = 1;
        
        if (helper(s1, s2, i1, i2 + len - k, k) &&
            helper(s1, s2, i1 + k, i2, len - k))
            return dp[i1][i2][len] = 1;
    }

    return dp[i1][i2][len] = 0;
}

bool isScramble(char *s1, char *s2) {
    int n = strlen(s1);
    if (n != strlen(s2)) return false;
    memset(dp, -1, sizeof(dp));
    return helper(s1, s2, 0, 0, n);
}
