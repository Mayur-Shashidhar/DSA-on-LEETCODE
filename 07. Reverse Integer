QUESTION:
Given a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the value to go outside the signed 32-bit integer range [-231, 231 - 1], then return 0.
Assume the environment does not allow you to store 64-bit integers (signed or unsigned).



APPROACH:
1.We build the reversed number digit-by-digit using modulo and division.
2.Before adding a new digit, check for possible overflow:
        If rev > INT_MAX / 10 → overflow
        If rev == INT_MAX / 10 and pop > 7 → overflow
        If rev < INT_MIN / 10 → overflow
        If rev == INT_MIN / 10 and pop < -8 → overflow


CODE:
#include <stdio.h>
#include <limits.h> // For INT_MAX and INT_MIN

int reverse(int x) {
    int rev = 0; // Will store the reversed number

    // Process digits until x becomes 0
    while (x != 0) {
        int pop = x % 10; // Extract last digit (could be negative for negative x)
        x /= 10;          // Remove last digit from x

        /**
         * Before multiplying rev by 10, check for overflow:
         *
         * For positive numbers:
         *   If rev > INT_MAX / 10, multiplying by 10 would overflow.
         *   If rev == INT_MAX / 10, adding a digit > 7 would overflow 
         *   (since INT_MAX = 2147483647, last digit is 7).
         *
         * For negative numbers:
         *   If rev < INT_MIN / 10, multiplying by 10 would underflow.
         *   If rev == INT_MIN / 10, adding a digit < -8 would underflow
         *   (since INT_MIN = -2147483648, last digit is -8).
         */
        if (rev > INT_MAX / 10 || (rev == INT_MAX / 10 && pop > 7))
            return 0; // Overflow detected

        if (rev < INT_MIN / 10 || (rev == INT_MIN / 10 && pop < -8))
            return 0; // Underflow detected

        // Push the digit to the right side of rev
        rev = rev * 10 + pop;
    }

    return rev; // Return reversed integer
}
