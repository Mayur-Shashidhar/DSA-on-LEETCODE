QUESTION:
Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.



APPROACH:
Backtracking (DFS)
A valid parentheses string must satisfy:
  1.We can only place '(' if we still have some left to place.
  2.We can only place ')' if there are more '(' placed already (i.e., right > left condition cannot happen).
So, we use backtracking:
  Keep track of:
    left: how many '(' we have placed so far
    right: how many ')' we have placed so far
Base case: when left == n and right == n → we have a valid combination → store it.
Choices:
    If left < n, we can add '('
    If right < left, we can add ')'



CODE:
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void backtrack(int n, int left, int right, char *current, char **result, int *returnSize) {
    if (left == n && right == n) {
        result[*returnSize] = strdup(current); 
        (*returnSize)++;
        return;
    }
    if (left < n) {
        current[left + right] = '(';
        backtrack(n, left + 1, right, current, result, returnSize);
    }
    if (right < left) {
        current[left + right] = ')';
        backtrack(n, left, right + 1, current, result, returnSize);
    }
}

char **generateParenthesis(int n, int *returnSize) {
    
    int maxComb = 1;
    for (int i = 0; i < n; i++) maxComb *= 4; 

    char **result = (char **)malloc(maxComb * sizeof(char *));
    char *current = (char *)malloc(2 * n + 1); 
    current[2 * n] = '\0';

    *returnSize = 0;
    backtrack(n, 0, 0, current, result, returnSize);

    free(current);
    return result;
}
